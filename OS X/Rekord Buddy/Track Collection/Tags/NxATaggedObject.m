//
//  Copyright (c) 2013-2015 Next Audio Labs, LLC. All rights reserved.
//
//  This file contains confidential and proprietary information of Next
//  Audio Labs, LLC ("Next"). No use is permitted without express written
//  permission of Next. If you are not a party to a Confidentiality/
//  Non-Disclosure Agreement with Next, please immediately delete this
//  file as well as all copies in your possession. For further information,
//  please email info@nextaudiolabs.com.
//

#import "NSDate+NxAUtility.h"
#import "Track Collection/Tags/NxATag.h"
#import "NxATagEntry.h"
#import "Track Collection/Tags/Internal/NxATaggedObject.h"
#import "NSManagedObjectContext+NxAUtility.h"
#import "NxATagDescription.h"
#import "NxAParsedValue.h"

#pragma mark Implementation

@implementation NxATaggedObject

#pragma mark Accessors

// -- Automatically generated by Core Data.
@dynamic p_tagEntries;
@dynamic p_savedTagValues;

// -- Automatically generated for properties.
@synthesize p_tagsByType = _p_tagsByType;
@synthesize p_tagEntriesByType = _p_tagEntriesByType;
@synthesize p_savedTagValuesByIdentifier = _p_savedTagValuesByIdentifier;

- (BOOL)p_isInitialized
{
    return _p_tagsByType != nil;
}

- (NSMutableDictionary *)p_tagsByType
{
    if (!_p_tagsByType) {
        [self p_initTaggedObject];
    }

    NxAAssertNotNil(_p_tagsByType);
    return _p_tagsByType;
}

- (NSMutableDictionary *)p_tagEntriesByType
{
    if (!_p_tagEntriesByType) {
        [self p_initTaggedObject];
    }

    NxAAssertNotNil(_p_tagEntriesByType);
    return _p_tagEntriesByType;
}

- (NSMutableDictionary *)p_savedTagValuesByIdentifier
{
    if (!_p_savedTagValuesByIdentifier) {
        [self p_initTaggedObject];
    }

    NxAAssertNotNil(_p_savedTagValuesByIdentifier);
    return _p_savedTagValuesByIdentifier;
}

- (NSArray *)tagTypesForSorting
{
    NSDictionary *sortedTagEntries = self.p_tagEntriesByType;
    NSArray *tagsNames = sortedTagEntries.allKeys;
    NSMutableDictionary *tagTypes = [NSMutableDictionary dictionary];

    for (NSString *name in tagsNames) {
        NSArray *tagEntriesFound = sortedTagEntries[name];
        NxATagEntry *firstEntry = tagEntriesFound.firstObject;
        NxATag *firstTag = firstEntry.tag;
        Class firstTagClass = firstTag.class;

        if (![firstTagClass sharesTags]) {
            // -- If these tags are not shared, they're not good candidates for sorting.
            continue;
        }

        if ([firstTagClass isATagTypeSortedByPropertyName]) {
            for (NxATagEntry *tagEntry in tagEntriesFound) {
                NxATag *tag = tagEntry.tag;
                if (tag.isNil) {
                    continue;
                }

                NSString *description = tag.propertyDescription;
                NxAAssertNotNil(description);
                tagTypes[description] = tag;
            }
        }
        else if (!firstTag.isNil) {
            NSString *description = firstTag.propertyDescription;
            NxAAssertNotNil(description);
            tagTypes[description] = firstTag;
        }
    }

    return tagTypes.allValues;
}

#pragma mark Instance Methods

- (NSArray *)p_entriesForType:(NSString *)tagType
{
    NSSet *entries = self.p_tagEntriesByType[tagType];
    return entries.allObjects;
}

- (void)p_sortTag:(NxATag *)tag
{
    NxAAssertNotNil(tag);

    NSString *type = [tag.class tagType];

    NSMutableDictionary *tagsSortedByType = self.p_tagsByType;
    NSMutableArray *tagsWithType = tagsSortedByType[type];
    if (!tagsWithType) {
        tagsWithType = [NSMutableArray array];
        tagsSortedByType[type] = tagsWithType;
    }

    [tagsWithType addObject:tag];
}

- (void)p_sortTagEntry:(NxATagEntry *)entry
{
    NxAAssertNotNil(entry);

    NxATag *tag = entry.tag;
    [self p_sortTag:tag];

    NSString *tagType = [tag.class tagType];

    // -- We update the dictionary of tag entries by type.
    NSMutableDictionary *tagEntriesSortedByType = self.p_tagEntriesByType;
    NSMutableArray *tagEntriesWithType = tagEntriesSortedByType[tagType];
    if (!tagEntriesWithType) {
        tagEntriesWithType = [NSMutableArray array];
        tagEntriesSortedByType[tagType] = tagEntriesWithType;
    }

    [tagEntriesWithType addObject:entry];
}

- (void)p_sortSavedTagValue:(NxATagDescription *)savedTagValue
{
    NxAAssertNotNil(savedTagValue);

    NSString *identifier = savedTagValue.identifier;

    NSMutableDictionary *savedTagValuesSortedByIdentifier = self.p_savedTagValuesByIdentifier;
    NSMutableArray *savedTagValuesWithIdentifier = savedTagValuesSortedByIdentifier[identifier];
    if (!savedTagValuesWithIdentifier) {
        savedTagValuesWithIdentifier = [NSMutableArray array];
        savedTagValuesSortedByIdentifier[identifier] = savedTagValuesWithIdentifier;
    }

    [savedTagValuesWithIdentifier addObject:savedTagValue];
}

- (void)p_initTaggedObject
{
    _p_tagsByType = [NSMutableDictionary dictionary];
    _p_tagEntriesByType = [NSMutableDictionary dictionary];
    _p_savedTagValuesByIdentifier = [NSMutableDictionary dictionary];

    NSOrderedSet *entries = self.p_tagEntries;
    for (NxATagEntry *entry in entries) {
        [self p_sortTagEntry:entry];
    }

    NSOrderedSet *savedTagValues = self.p_savedTagValues;
    for (NxATagDescription *savedTagValue in savedTagValues) {
        [self p_sortSavedTagValue:savedTagValue];
    }
}

- (void)p_addAndSortTagEntry:(NxATagEntry *)entry
{
    NxAAssertNotNil(entry);

    [self p_sortTagEntry:entry];

    NSMutableOrderedSet *existingEntries = [self mutableOrderedSetValueForKey:@"p_tagEntries"];
    [existingEntries addObject:entry];
}

- (void)p_addTagWithoutMarkingTagsWithSameTypeAsModified:(NxATag *)tag
                                          lastModifiedOn:(NSDate *)date
{
    NxAAssertNotNil(tag);
    NxAAssertNotNil(date);

    NxATagEntry *newEntry = [NxATagEntry entryWithTag:tag
                                         dateModified:date
                                              context:self.managedObjectContext];
    [self p_addAndSortTagEntry:newEntry];
}

- (void)p_replaceTagClass:(Class)tagClass
                  andName:(NSString *)name
                 withTags:(NSArray *)tags
         modificationDate:(NSDate *)date
{
    NSArray *existingTagEntries = self.p_tagEntriesByType[[tagClass tagType]];
    NSArray *existingTagEntriesWithName = [NxATagEntry entriesWithTagName:name entries:existingTagEntries];
    for (NxATagEntry *entry in existingTagEntriesWithName) {
        [self removeTagEntry:entry];
    }

    if (!tags.count) {
        tags = @[ [tagClass tagWithValue:nil context:self.managedObjectContext] ];
    }

    for (NxATag *tag in tags) {
        [self p_addTagWithoutMarkingTagsWithSameTypeAsModified:tag lastModifiedOn:date];
    }

    for (NxATagEntry *entry in existingTagEntriesWithName) {
        [entry destroy];
    }
}

- (void)p_replaceTagClass:(Class)tagClass
                 withTags:(NSArray *)tags
         modificationDate:(NSDate *)date
{
    NSArray *existingTagEntries = [self.p_tagEntriesByType[[tagClass tagType]] copy];
    for (NxATagEntry *entry in existingTagEntries) {
        [self removeTagEntry:entry];
    }

    if (!tags.count) {
        tags = @[ [tagClass tagWithValue:nil context:self.managedObjectContext] ];
    }

    for (NxATag *tag in tags) {
        [self p_addTagWithoutMarkingTagsWithSameTypeAsModified:tag lastModifiedOn:date];
    }

    for (NxATagEntry *entry in existingTagEntries) {
        [entry destroy];
    }
}

- (void)p_replaceTagClass:(Class)tagClass
         withParsedValues:(NSArray *)values
         modificationDate:(NSDate *)date
{
    NSManagedObjectContext *context = self.managedObjectContext;

    NSMutableArray *newTags = [NSMutableArray arrayWithCapacity:values.count];
    for (NxAParsedValue *value in values) {
        NxATag *tag = [value tagForClass:tagClass usingContext:context];
        [newTags addObject:tag];
    }

    [self p_replaceTagClass:tagClass withTags:newTags modificationDate:date];
}

- (void)p_replaceTagClass:(Class)tagClass
                  andName:(NSString *)name
         withParsedValues:(NSArray *)values
         modificationDate:(NSDate *)date
{
    NSManagedObjectContext *context = self.managedObjectContext;
    
    NSMutableArray *newTags = [NSMutableArray arrayWithCapacity:values.count];
    for (NxAParsedValue *value in values) {
        NxATag *tag = [value tagForClass:tagClass withName:name usingContext:context];
        [newTags addObject:tag];
    }
    
    [self p_replaceTagClass:tagClass andName:name withTags:newTags modificationDate:date];
}

- (void)p_moveTagType:(NSString *)type
                 tags:(NSArray *)tags
           toPosition:(NSInteger)index
{
    // -- We will re-order the tags so we first remove all the entries in our list of entries
    NSMutableArray *tagEntriesForType = [self.p_tagEntriesByType[type] mutableCopy];
    for (NxATagEntry *entry in tagEntriesForType) {
        [self removeTagEntry:entry];
    }

    NSMutableArray *entriesToMove = [NSMutableArray array];

    // -- First we find the indices of the tags we're moving in the list of tag entries sorted by type.
    for (NxATag *tag in tags) {
        NSUInteger tagEntryIndex = [NxATagEntry indexOfTagEntryForTag:tag
                                                            inEntries:tagEntriesForType];
        NxAAssertTrue(tagEntryIndex != NSNotFound);

        [entriesToMove addObject:tagEntriesForType[tagEntryIndex]];

        if (tagEntryIndex < index) {
            // -- If we're moving an entry placed before the destination index, we update
            // -- the index since we will delete entries before re-adding them
            // -- which means the destination index has to be the one valid AFTER deletion of the entries we're moving.
            --index;
        }
    }

    // -- Then delete the entries we're moving in the cache.
    for (NxATagEntry *entryToMove in entriesToMove) {
        [tagEntriesForType removeObject:entryToMove];
    }

    // -- Then we move the entries into their new location.
    for (NxATagEntry *entryToMove in entriesToMove) {
        [tagEntriesForType insertObject:entryToMove atIndex:index];
        ++index;
    }

    // -- We mark all the entries for the type as modified now.
    NSDate *now = [NSDate date];
    [NxATagEntry markEntries:tagEntriesForType asModified:now];

    // -- And finally re-sort the tag entries into the tagged object.
    for (NxATagEntry *entry in tagEntriesForType) {
        [self p_addAndSortTagEntry:entry];
    }
}

- (void)p_saveValues:(NSArray *)values
         forTagClass:(Class)tagClass
             andName:(NSString *)name
          andVersion:(NSString *)versionPrefix
{
    NxAAssertTrue(values.count != 0);
    NxAAssertNotNil(versionPrefix);

    NSString *tagType = [tagClass tagType];
    NSString *identifier =  name ? [NxATagDescription identifierForTagType:tagType andTagName:name andVersionPrefix:versionPrefix] :
    [NxATagDescription identifierForTagType:tagType andVersionPrefix:versionPrefix];

    // -- We go through saved tag values this object has and removed them.
    NSMutableArray *savedTagValuesWithIdentifier = self.p_savedTagValuesByIdentifier[identifier];
    for (NxATagEntry *savedTagValue in savedTagValuesWithIdentifier) {
        [savedTagValue destroy];
    }

    NSMutableOrderedSet *existingSavedValues = [self mutableOrderedSetValueForKey:@"p_savedTagValues"];

    // -- Then we save the new values.
    for (NxAParsedValue *value in values) {
        NxATagDescription *newSavedTagValue = [NxATagDescription descriptionForValue:value
                                                                       andIdentifier:identifier
                                                                           inContext:self.managedObjectContext];
        [existingSavedValues addObject:newSavedTagValue];
        [self p_sortSavedTagValue:newSavedTagValue];
    }
}

- (void)addNilTagForTagClass:(Class)tagClass
                  modifiedOn:(NSDate *)date
{
    NxATag *emptyTag = [tagClass tagWithValue:nil context:self.managedObjectContext];
    [self p_addTagWithoutMarkingTagsWithSameTypeAsModified:emptyTag lastModifiedOn:date];
}

- (void) addTag:(NxATag *)tag
 lastModifiedOn:(NSDate *)date
{
    Class tagClass = tag.class;
    NSString *tagType = [tagClass tagType];

    if ([self hasNonNilTagsWithType:tagType] && ![tag.class isASingleValueTagType]) {
        [self p_addTagWithoutMarkingTagsWithSameTypeAsModified:tag lastModifiedOn:date];

        // -- We mark all the properties as being modified on the date.
        NSArray *entries = [self p_entriesForType:tagType];
        [NxATagEntry markEntries:entries asModified:date];
    }
    else {
        [self p_replaceTagClass:tagClass withTags:@[ tag ] modificationDate:date];
    }
}

- (NxATagEntryModificationCompareFlag)compareTagClass:(Class)tagClass
                                   toModificationDate:(NSDate *)date
{
    NSMutableArray *entries = self.p_tagEntriesByType[[tagClass tagType]];
    if (!entries) {
        return NxATagTypeWasLastModifiedBeforeDate;
    }

    NxATagEntry *firstEntry = entries.firstObject;
    return [firstEntry compareToModificationDate:date];
}

- (NxATagEntryModificationCompareFlag)compareTagClass:(Class)tagClass
                                             withName:(NSString *)name
                                   toModificationDate:(NSDate *)date
{
    NSMutableArray *entries = self.p_tagEntriesByType[[tagClass tagType]];
    if (entries) {
        NxATagEntry *firstEntry = [NxATagEntry firstEntryWithTagName:name entries:entries];
        if (firstEntry) {
            return [firstEntry compareToModificationDate:date];
        }
    }

    return NxATagTypeWasLastModifiedBeforeDate;
}

- (void)destroy
{
    [self resetCaches];

    if (self.p_tagEntries.count) {
        NSOrderedSet *entriesCopy = self.p_tagEntries.copy;
        [[self mutableOrderedSetValueForKey:@"p_tagEntries"] removeAllObjects];

        for (NxATagEntry *entry in entriesCopy) {
            [entry destroy];
        }
    }

    if (self.p_savedTagValues.count) {
        NSOrderedSet *savedValuesCopy = self.p_savedTagValues.copy;
        [[self mutableOrderedSetValueForKey:@"p_savedTagValues"] removeAllObjects];

        for (NxATagDescription *savedValue in savedValuesCopy) {
            [savedValue destroy];
        }
    }

    [self.managedObjectContext deleteObject:self];
}

- (void)removeTagEntry:(NxATagEntry *)entry
{
    NxATag *tag = entry.tag;
    NxAAssertNotNil(tag);
    
    Class tagClass = tag.class;
    NSString *type = [tagClass tagType];

    if (self.p_isInitialized) {
        // -- First remove it from the dictionary of tags sorted by type.
        NSMutableDictionary *tagsSortedByType = self.p_tagsByType;
        NSMutableArray *tagsForType = tagsSortedByType[type];
        [tagsForType removeObject:tag];

        // -- Then remove it from the list of entries sorted by type.
        NSMutableDictionary *tagEntriesSortedByType = self.p_tagEntriesByType;
        NSMutableArray *tagEntriesWithType = tagEntriesSortedByType[type];
        [tagEntriesWithType removeObject:entry];
    }

    // -- Then remove it from the list of entries.
    NSMutableOrderedSet *existingEntries = [self mutableOrderedSetValueForKey:@"p_tagEntries"];
    [existingEntries removeObject:entry];
}

- (void)resetCaches
{
    self.p_tagsByType = nil;
    self.p_tagEntriesByType = nil;
    self.p_savedTagValuesByIdentifier = nil;
}

- (void)removeTagsWithClass:(Class)tagClass
{
    NSString *tagType = [tagClass tagType];

    if ([[self nonNilTagsWithType:tagType] count] == 0) {
        return;
    }

    NSDate *now = [NSDate date];
    [self p_replaceTagClass:tagClass withTags:@[ ] modificationDate:now];
}

- (void)removeTagsWithClass:(Class)tagClass
                    andName:(NSString *)name
{
    NSString *tagType = [tagClass tagType];

    if ([[self nonNilTagsWithType:tagType] count] == 0) {
        return;
    }

    NSDate *now = [NSDate date];
    [self p_replaceTagClass:tagClass andName:name withTags:@[ ] modificationDate:now];
}

- (void)saveValues:(NSArray *)values
       forTagClass:(Class)tagClass
        andVersion:(NSString *)versionPrefix
{
    [self p_saveValues:values forTagClass:tagClass andName:nil andVersion:versionPrefix];
}

- (void)saveValues:(NSArray *)values
       forTagClass:(Class)tagClass
           andName:(NSString *)name
        andVersion:(NSString *)versionPrefix
{
    NxAAssertNotNil(name);

    [self p_saveValues:values forTagClass:tagClass andName:name andVersion:versionPrefix];
}

- (BOOL)hasTagsWithType:(NSString *)type
{
    NSArray *results = self.p_tagEntriesByType[type];
    return results.count != 0;
}

- (BOOL)hasNonNilTagsWithType:(NSString *)type
{
    NSArray *results = self.p_tagEntriesByType[type];
    if (!results.count) {
        return NO;
    }

    NxATagEntry *firstTagEntry = results.firstObject;
    return !firstTagEntry.tag.isNil;
}

- (NSArray *)allTagsWithType:(NSString *)type
{
    NSArray *entries = self.p_tagEntriesByType[type];

    NSMutableArray *results = [NSMutableArray arrayWithCapacity:entries.count];
    for (NxATagEntry *entry in entries) {
        [results addObject:entry.tag];
    }

    return results;
}

- (NSArray *)allTagsWithType:(NSString *)type
                     andName:(NSString *)name
{
    NSArray *results = [self allTagsWithType:type];
    if (!results.count) {
        return @[ ];
    }

    return [NxATag tagsInTags:results withName:name];
}

- (NSArray *)nonNilTagsWithType:(NSString *)type
{
    NSArray *results = self.p_tagsByType[type];
    if (!results.count) {
        return @[ ];
    }

    NxATag *firstTag = results.firstObject;
    return firstTag.isNil ? @[ ] : results;
}

- (NSArray *)nonNilTagsWithType:(NSString *)type
                        andName:(NSString *)name
{
    NSArray *results = [self nonNilTagsWithType:type];
    if (!results.count) {
        return @[ ];
    }

    return [NxATag tagsInTags:results withName:name];
}

- (BOOL)  parsedValues:(NSArray *)values
           forTagClass:(Class)tagClass
   areTheSameAsVersion:(NSString *)versionPrefix
{
    NSString *identifier = [NxATagDescription identifierForTagType:[tagClass tagType]
                                                  andVersionPrefix:versionPrefix];
    NSArray *savedValues = self.p_savedTagValuesByIdentifier[identifier];
    if (!savedValues) {
        return NO;
    }

    return [NxATagEntry parsedValues:values
                         forTagClass:tagClass
             areTheSameAsSavedValues:savedValues];
}

- (BOOL)  parsedValues:(NSArray *)values
           forTagClass:(Class)tagClass
              withName:(NSString *)name
   areTheSameAsVersion:(NSString *)versionPrefix
{
    NSString *identifier = [NxATagDescription identifierForTagType:[tagClass tagType]
                                                        andTagName:name
                                                  andVersionPrefix:versionPrefix];
    NSArray *savedValues = self.p_savedTagValuesByIdentifier[identifier];
    if (!savedValues) {
        return NO;
    }

    return [NxATagEntry parsedValues:values
                         forTagClass:tagClass
             areTheSameAsSavedValues:savedValues];
}

- (void)sortTag:(NxATag *)tag
           type:(NSString *)type
          entry:(NxATagEntry *)entry
{
    ALog(@"Invalid base class call.");
}

- (void)addAndSortTag:(NxATag *)tag
             tagEntry:(NxATagEntry *)entry
{
    ALog(@"Invalid base class call.");
}

- (void)removeTag:(NxATag *)tag
         tagEntry:(NxATagEntry *)entry
{
    ALog(@"Invalid base class call.");
}

@end
